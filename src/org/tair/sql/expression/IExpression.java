/*
 * Copyright (c) 2012 Carnegie Institution for Science. All rights reserved.
 */

package org.tair.sql.expression;

import java.util.Map;

/**
 * <p>
 * An interface defining the operations available for any SQL expression
 * </p>
 * <p>
 * A SQL value expression represented as a string that you can append to a
 * StringBuilder while constructing a SQL statement. The expression is intended
 * to be one of these types:
 * </p>
 * <ul>
 * <li>a column reference</li>
 * <li>a function call</li>
 * <li>an arithmetic expression</li>
 * <li>a subquery (table, row, or scalar)</li>
 * </ul>
 * <p>
 * Other possibilities are there, but the expression has no internal structure
 * other than lexical substitution variables. In particular, value expressions
 * that are boolean expressions are handled separately as "predicates", while a
 * simple boolean expression returning (for example) a column value of true or
 * false is an expression, not a predicate. This division allows for relatively
 * complex predicates but handles every other kind of expression as an
 * unstructured string.
 * </p>
 * <p>
 * The lexical variable substitution interface allows the client to substitute a
 * string value into the internal expression string, which may have embedded
 * variable values in the format ${var}. The concrete expression implementation
 * should represent the expression string with the variable and code a method
 * for resolving the variable into the setVariable method. If the variable does
 * not exist in the expression, the setVariable method should throw an
 * exception.
 * </p>
 * 
 * @author Robert J. Muller
 */
public interface IExpression {
  /**
   * Append the SQL expression into the string builder.
   * 
   * @param builder the string builder into which to append the elements of the
   *          SQL expression; the builder may already contain the preceding part
   *          of the SQL statement
   */
  void getSql(StringBuilder builder);

  /**
   * Get the current value of a lexical variable; if the variable does not exist
   * in the lexical variable map, returns null
   * 
   * @param variable the name of the variable for which to get the value
   * @return the value of the variable specified
   * @throws NoSuchLexicalVariableException when the variable does not exist in
   *           the map of variables
   */
  String getVariable(String variable) throws NoSuchLexicalVariableException;

  /**
   * Set the value of a lexical variable; if the variable does not exist, throws
   * a runtime exception.
   * 
   * @param variable the name of the lexical variable
   * @param value the value to assign to the lexical variable and to substitute
   *          for it in the SQL string generated by the getSQL method
   * @throws NoSuchLexicalVariableException when the variable does not exist in
   *           the map of variables
   */
  void setVariable(String variable, String value)
      throws NoSuchLexicalVariableException;
  
  /**
   * Get the expression as a string.
   * 
   * @return the expression as a string
   */
  String getExpression();
  
  /**
   * Get a copy of the internal map of variables.
   * 
   * @return a Map of variables
   */
  Map<String, String> getLexicalVariables();
}
